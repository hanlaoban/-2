<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cosmic Math: UNIVERSAL MODE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; touch-action: none; }
        
        /* 容器与背景 */
        #container { position: relative; width: 100vw; height: 100vh; overflow: hidden; background: #000; }
        
        /* 1. 视频层 (隐藏) */
        #video-feed { display: none; }
        
        /* 2. 骨骼层 */
        #skeleton-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; z-index: 10; pointer-events: none; transform: scaleX(-1);
            opacity: 0.4; 
        }

        /* 3. 3D 粒子层 (背景改为极深蓝紫，增强对比度) */
        #three-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 5; 
            background: radial-gradient(circle at center, #1a0b2e 0%, #000000 90%);
        }

        /* UI */
        #ui-layer { 
            position: absolute; top: 20px; left: 20px; color: #fff; z-index: 20; pointer-events: none; 
            text-shadow: 0 0 5px #00ffff;
        }
        .title { font-size: 18px; font-weight: bold; color: #00ffff; margin-bottom: 5px; border-left: 3px solid #fff; padding-left: 8px;}
        .hud-text { font-size: 12px; opacity: 0.8; line-height: 1.5; }

        #loading { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; z-index: 50; font-size: 14px; 
            background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #00ffff;
        }

        #gui-container { position: absolute; top: 10px; right: 10px; z-index: 100; }
        .lil-gui { --background-color: rgba(10,10,10,0.8); --text-color: #0ff; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
</head>
<body>

    <div id="container">
        <video id="video-feed" playsinline></video>
        <canvas id="skeleton-canvas"></canvas>
        <div id="three-canvas"></div>
    </div>

    <div id="loading">STARTING UNIVERSAL ENGINE...</div>

    <div id="ui-layer">
        <div class="title">COSMIC MATH [COMPATIBLE]</div>
        <div class="hud-text">
            PARTICLES: 30,000<br>
            STATUS: <span id="status" style="color:red">WAITING...</span><br>
            SHAPE: <span id="model-name">QUANTUM_TREE</span>
        </div>
    </div>
    
    <div id="gui-container"></div>

    <script type="module">
        import * as THREE from 'three';

        const CONFIG = {
            count: 30000,
            size: 0.15,        // 标准世界单位尺寸
            morphSpeed: 0.05,
            autoSpin: true,
            repulseRange: 2.5
        };

        let scene, camera, renderer, particles, geometry, material;
        let positions, targetPositions, colors;
        let skeletonCtx, skeletonCanvas;
        let time = 0;
        let currentShapeIndex = 0;
        
        let handPosition = new THREE.Vector3(999, 999, 999);
        let isPinching = false, isFist = false, prevFist = false;
        let isExploding = false; 

        // 形状生成器
        const SHAPES = [
            { name: "QUANTUM_TREE", func: getTreePoint },
            { name: "FRACTAL_KOCH", func: getFractalPoint },
            { name: "CARDIOID_HEART", func: getCardioidPoint },
            { name: "BUTTERFLY_CHAOS", func: getButterflyPoint },
            { name: "ARCHIMEDES_SPIRAL", func: getSpiralPoint },
            { name: "BERNOULLI_LOOP", func: getBernoulliPoint },
            { name: "ROSE_GALAXY", func: getRosePoint }
        ];

        async function init() {
            const container = document.getElementById('three-canvas');
            scene = new THREE.Scene();
            
            // 相机设置：确保 Z 轴距离足够
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 6); 

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            skeletonCanvas = document.getElementById('skeleton-canvas');
            skeletonCtx = skeletonCanvas.getContext('2d');
            resizeCanvas();

            initParticles();
            setupGUI();

            const videoElement = document.getElementById('video-feed');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480 
            });
            cameraUtils.start();

            document.getElementById('loading').style.display = 'none';
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // --- 核心修复：生成发光纹理 ---
        function generateSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0,0,32,32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function initParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(CONFIG.count * 3);
            targetPositions = new Float32Array(CONFIG.count * 3);
            colors = new Float32Array(CONFIG.count * 3);

            const palette = [
                new THREE.Color(0x00ffff), new THREE.Color(0xff00ff), 
                new THREE.Color(0xffd700), new THREE.Color(0xffffff)
            ];

            for(let i=0; i<CONFIG.count; i++) {
                positions[i*3] = (Math.random()-0.5)*5;
                positions[i*3+1] = (Math.random()-0.5)*5;
                positions[i*3+2] = (Math.random()-0.5)*5;

                const c = palette[Math.floor(Math.random() * palette.length)];
                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // --- 核心修复：使用标准 PointsMaterial ---
            // 这种材质不依赖 GPU Shader 编译，兼容性最好
            material = new THREE.PointsMaterial({
                size: CONFIG.size,
                map: generateSprite(), // 使用生成的发光贴图
                vertexColors: true,    // 启用顶点颜色
                blending: THREE.AdditiveBlending, // 叠加发光模式
                depthWrite: false,     // 不遮挡背景
                transparent: true,
                sizeAttenuation: true  // 远小近大
            });

            particles = new THREE.Points(geometry, material);
            
            // --- 核心修复：关闭视锥剔除 ---
            // 这确保了无论粒子怎么移动，都不会被系统误认为“在屏幕外”而隐藏
            particles.frustumCulled = false; 

            scene.add(particles);
            calculateTargetShape(0);
        }

        // --- MATH FUNCTIONS (不变) ---
        function calculateTargetShape(index) {
            const func = SHAPES[index].func;
            const count = CONFIG.count;
            for(let i=0; i<count; i++) {
                const p = i / count;
                const res = func(p, i);
                targetPositions[i*3] = res.x;
                targetPositions[i*3+1] = res.y;
                targetPositions[i*3+2] = res.z;
            }
            document.getElementById('model-name').innerText = SHAPES[index].name;
        }

        function getTreePoint(p, i) {
            const h = p * 4 - 2; 
            const r = (2 - h) * 0.5 * Math.random();
            const theta = i * 0.1;
            return { x: Math.cos(theta)*r, y: h, z: Math.sin(theta)*r };
        }
        function getFractalPoint(p, i) {
            return { x: (Math.random()-0.5)*3, y: (Math.random()-0.5)*3, z: (Math.random()-0.5)*3 };
        }
        function getCardioidPoint(p, i) {
            const t = p * Math.PI * 2;
            const scale = 0.1;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
            return { x: x*scale, y: y*scale, z: (Math.random()-0.5) };
        }
        function getButterflyPoint(p, i) {
            const t = p * 12 * Math.PI;
            const r = Math.exp(Math.cos(t)) - 2*Math.cos(4*t) + Math.pow(Math.sin(t/12),5);
            return { x: Math.sin(t)*r*0.5, y: Math.cos(t)*r*0.5, z: (Math.random()-0.5)*0.5 };
        }
        function getSpiralPoint(p, i) {
            const t = p * 20 * Math.PI;
            return { x: Math.cos(t)*p*3, y: Math.sin(t)*p*3, z: (p-0.5)*5 };
        }
        function getBernoulliPoint(p, i) {
            const t = p * 2 * Math.PI;
            const den = 1 + Math.pow(Math.sin(t), 2);
            return { x: 2*Math.cos(t)/den, y: 2*Math.cos(t)*Math.sin(t)/den, z: (Math.random()-0.5)*0.5 };
        }
        function getRosePoint(p, i) {
            const k = 4; const t = p*2*Math.PI; const r = Math.cos(k*t)*2.5;
            return { x: r*Math.cos(t), y: r*Math.sin(t), z: (Math.random()-0.5)*0.5 };
        }

        // --- Interaction ---
        function onHandsResults(results) {
            skeletonCtx.clearRect(0, 0, skeletonCanvas.width, skeletonCanvas.height);
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                drawConnectors(skeletonCtx, lm, HAND_CONNECTIONS, {color: '#00ffff', lineWidth: 2});
                drawLandmarks(skeletonCtx, lm, {color: '#ffffff', lineWidth: 1, radius: 2});

                const x = (1 - lm[8].x) * 2 - 1;
                const y = -(lm[8].y * 2 - 1);
                const vec = new THREE.Vector3(x, y, 0.5).unproject(camera);
                const dir = vec.sub(camera.position).normalize();
                const dist = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(dist));
                
                handPosition.lerp(pos, 0.2);
                document.getElementById('status').innerText = "LINKED";
                document.getElementById('status').style.color = "#00ffff";
                detectGestures(lm);
            } else {
                handPosition.set(999,999,999);
                document.getElementById('status').innerText = "SEARCHING";
                document.getElementById('status').style.color = "red";
            }
        }

        function detectGestures(lm) {
            const tips = [8,12,16,20];
            let folded = 0;
            tips.forEach(t => { if(lm[t].y > lm[t-2].y) folded++; });
            isFist = folded >= 3;

            if (isFist && !prevFist) triggerExplosion();
            prevFist = isFist;

            const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y);
            isPinching = pinch < 0.05;

            if (isPinching) {
                const rot = (lm[8].x - 0.5) * 0.2;
                particles.rotation.y += rot;
            } else if (CONFIG.autoSpin) {
                particles.rotation.y += 0.002;
            }
        }

        function triggerExplosion() {
            if(isExploding) return;
            isExploding = true;
            setTimeout(() => {
                currentShapeIndex = (currentShapeIndex + 1) % SHAPES.length;
                calculateTargetShape(currentShapeIndex);
                isExploding = false;
            }, 300);
        }

        // --- GUI ---
        function setupGUI() {
            const gui = new lil.GUI({ container: document.getElementById('gui-container'), title: 'SETTINGS' });
            gui.close();
            gui.add(CONFIG, 'size', 0.05, 0.5).name('Size').onChange(v => material.size = v);
            gui.add({ next: triggerExplosion }, 'next').name('>> Next Shape');
        }

        function resizeCanvas() {
            skeletonCanvas.width = window.innerWidth;
            skeletonCanvas.height = window.innerHeight;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            resizeCanvas();
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            if (particles) {
                const pos = geometry.attributes.position.array;
                let updated = false;

                // CPU Morphing Logic
                for(let i=0; i<CONFIG.count * 3; i+=3) { // i, i+1, i+2
                    // 1. Interaction (Repulsion)
                    let px = pos[i], py = pos[i+1], pz = pos[i+2];
                    
                    // Move towards target
                    if (!isExploding) {
                        px += (targetPositions[i] - px) * CONFIG.morphSpeed;
                        py += (targetPositions[i+1] - py) * CONFIG.morphSpeed;
                        pz += (targetPositions[i+2] - pz) * CONFIG.morphSpeed;
                    } else {
                        // Explosion Noise
                        px += (Math.random()-0.5) * 0.2;
                        py += (Math.random()-0.5) * 0.2;
                        pz += (Math.random()-0.5) * 0.2;
                    }

                    // Hand Repulsion
                    const dx = px - handPosition.x;
                    const dy = py - handPosition.y;
                    const dz = pz - handPosition.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (dist < CONFIG.repulseRange) {
                        const force = (1.0 - dist/CONFIG.repulseRange) * 0.2;
                        px += (dx/dist) * force;
                        py += (dy/dist) * force;
                        pz += (dz/dist) * force;
                    }

                    pos[i] = px; pos[i+1] = py; pos[i+2] = pz;
                }
                
                geometry.attributes.position.needsUpdate = true;
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
